#动态规划
w权重 , v价格
N物品个数
i：只从前i个物品中选择
######1.01背包每件物品只能用一次
######2.完全背包每件物品能用无线次
######3.多重背包每个物品的个数不一样
    （1）优化版
######4.分组背包问题，N组，每组若干种，每组最多选择一个

##Dp两个角度考虑
###1.状态表示f(i，j)

    (1)集合：所有选法的集合，
        第一个条件：只考虑前i个物品
        第二个条件：选出物品总体积小于等于j

    (2)集合的属性：最大值，最小值，元素数量
    优化：代码的变形

###2.状态计算
集合的划分:使得每一个子集能被更小的子集计算出来

    
    f(n,v)所有n个物品,选出物品总体积小于等于背包容量v的 最大值
    f(i,j)的值如何计算(状态转换方程）：集合的划分为两个对立子集，分别为
        （1）含有i的集合
             1-i中选择，且总体积不超过j，且包含第i个物品
            去除第i个物品,第i个物品的体积为vi,价值为wi
            f(i-1,j-vi)+wi为最大价值
            当转不下第i个物品时，该情况不存在
        （2）不包含i的集合
            1-（i-1）中选择，且总体积不超过j，不包含第i个物品
            f(i-1,j)为最大价值
    f(i,j) = MAX{f(i-1,j-vi)+wi,f(i-1,j)}


动态规划问题：
状态表示：f(i,j)
    （1）集合：
    （2）属性：
    
**状态计算：**
    集合的划分
        0-1分为两块：划分依据，第i个物品是否选择
        完全背包：划分依据：分为多组，第i个物品选择多少个
            0-k个，
            状态转移方程
            0:f[i,j] = f[i-1,j]
            k:f[i,j] = f[i-1,j-k*v[i]]+k*w[i]
            1.去掉k个物品i；
            2.求Max(f[i-1,j-k*v[i]])
            3.再加回k个物品i
            综上可得：
            f[i,j] = f[i-1,j-k*v[i]]+k*w[i]
            
        *完全背包问题的优化*：
        f[i,j]      =   max(f[i-1,j],   f[i-1,j-v[i]]+w[i], f[i-1,j-2*v[i]]+2*w[i], f[i-1,j-3*v[i]]+3*w[i],···)
        f[i,j-v]    =   max(            f[i-1,j-v[i]],      f[i-1,j-2*v[i]]+*w[i], f[i-1,j-3*v[i]]+*2w[i],···)
        f[i,j] = max(f[i-1,j],f[i,j-v]+w[i])
---
```c++
    for(int i = 0;i<=n;i++)
    {
        cin>>v[i]>>w[i];
    }
    for(int i = 1;i<=n;i++)
    {
        for(int j = 0;j <= m;j++)
        {
            for(int k = 0;k*v[i]<= j;k++)
            {
                f[i][j] = max(f[i-1][j],f[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
```


